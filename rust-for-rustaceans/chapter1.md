# Fundations

​    当你深入到Rust的更高级的角落时，重要的是你要确保你对基本原理有一个坚实的理解。在Rust中，就像任何编程语言一样，当你开始以更复杂的方式使用该语言时，各种关键字和概念的精确含义变得非常重要。在本章中，我们将浏览Rust的许多(primitives)基元，并试图更清楚地定义它们的含义，它们是如何工作的，以及为什么它们是这样的。具体来说，我们将看看变量和值有什么不同，它们在内存中是如何表示的，以及一个程序有哪些不同的内存区域。然后，我们将讨论一些所有权(ownership)、借用(borrowing)和生命周期(lifetimes)的微妙之处，在你继续阅读本书之前，你需要掌握这些微妙之处。

​    如果你愿意，你可以从头到尾地阅读这一章，也可以把它作为参考，来温习那些你觉得不太确定的概念。我建议你只有在对这一章的内容感到完全满意时才继续阅读，因为对这些基元(primitives)如何工作的误解会很快妨碍你理解更高级的主题，或者导致你错误地使用它们。

## Taling About Memory

​    并非所有的内存都是平等的。在大多数编程环境中，你的程序可以访问堆栈、堆、寄存器、文本段、内存映射的寄存器、内存映射的文件，也许还有非易失性RAM。在特定情况下，你选择使用哪一个，对你能在那里存储什么，它能保持多长时间，以及你用什么机制来访问它都有影响。这些内存区域的具体细节因平台而异，超出了本书的范围，但有些内存区域对你如何推理Rust代码非常重要，因此值得在此介绍。

### Memory Terminology

在我们深入研究内存区域之前，你首先需要了解值、变量和指针之间的区别。Rust中的值是一个类型和该类型的值域的一个元素的组合。一个值可以使用其类型的表示法变成一串字节，但就其本身而言，你可以认为一个值更像是你这个程序员的意思。例如，u8类型中的数字6是数学整数6的一个实例，它在内存中的表示是字节0x06。同样，字符串 "Hello world "是所有字符串域中的一个值，其表示方法是UTF-8编码。一个值的意义与这些字节存储的位置无关。

一个值被存储在一个地方，这是Rust的术语，意思是 "一个可以容纳一个值的位置"。这个地方可以在堆栈中，也可以在堆上，或者在其他一些位置。最常见的存储值的地方是一个变量，它是堆栈上的一个命名值槽。

"指针"是一个持有内存区域地址的数值，因此指针指向一个地方。指针可以被取消引用，以访问存储在它所指向的内存位置的值。我们可以在一个以上的变量中存储相同的指针，因此有多个变量间接指向内存中的同一位置，从而有相同的基础值。

考虑清单1-1中的代码，它说明了这三个要素。

<script src="https://gist.github.com/rust-play/9f8e9436429abde98098f571f3bc1258.js"></script>

```rust
// Listing 1-1: Values, variables,and pointers
let x = 42;
let y = 43;
let var1 = &x;
let mut var2 = &x;
1: var2 = &y;
```

这里，有四个不同的值: 42（i32），43（i32），x的地址（pointer），以及y的地址（pointer）。还有四个变量：x、y、var1和var2。后两个变量都持有指针类型的值，因为引用是指针。虽然var1和var2最初存储的是同一个值，但它们分别存储该值的独立副本；当我们改变var2 中存储的值时，var1中的值不会改变。特别是，= 运算符将右侧表达式的值存储在左侧命名的地方。

变量、值和指针之间的区别变得很重要的一个有趣的例子是在这样的语句中：

```rust
let string = "Hello, world";
```

尽管我们给变量string分配了一个字符串值，但该变量的实际值是一个指向字符串值 "Hello world "中第一个字符的指针，而不是字符串值本身。这时你可能会说："但是等一下，那么字符串值是在哪里存储的？指针指向哪里？" 如果是这样，你的眼光就很敏锐了--我们一会儿就会说到这一点。

> 从技术上讲，字符串的值还包括字符串的长度。我们将在第二章讨论宽指针类型时谈论这个问题。

### Variables in Depth

我之前给出的变量定义很宽泛，本身不太可能有什么用。当你遇到更复杂的代码时，你将需要一个更准确的心理模型来帮助你推理出程序的真正作用。我们可以利用许多这样的模型。详细描述它们会占用好几章的篇幅，也超出了本书的范围，但广义上讲，它们可以分为两类：高层模型和低层模型。高层模型在思考生命周期和借用层面的代码时很有用，而低层模型在推理不安全代码和原始指针时很有用。下面两节描述的变量模型对于本书的大部分材料来说已经足够了。

#### Hight-Level Model

​    在高层模型中，我们不认为变量是存放字节的地方。相反，我们认为它们只是在整个程序中被实例化、移动和使用时赋予数值的名称。当你给一个变量赋值的时候，这个值就会被这个变量命名。**当一个变量后来被访问时，你可以想象从该变量以前的访问到新的访问画一条线，这在两个访问之间建立了一种依赖关系。如果一个变量中的值被移动了，就不能再从它那里画线。**

   在这个模型中，一个变量只有在它持有合法的值时才存在；你不能从一个值未被初始化或已被移动的变量上画线，所以实际上它不存在。使用这个模型，你的整个程序由许多这样的依赖线组成，通常称为流，每个流都追踪一个值的特定实例的生命周期。当有分支时，流可以分叉和合并，每一个分叉都追踪该值的一个不同的生命周期。编译器可以检查在程序的任何给定点，所有可以相互平行存在的流都是兼容的。例如，不能有两个并行的流对一个值进行可变的访问。也不能有一个流借用一个值，而没有一个流拥有该值。清单1-2显示了这两种情况的例子。

<script src="https://gist.github.com/rust-play/e013463a91d0cb7e58bb0251cc00c3ee.js"></script>

```rust
// listing 1-2: Illegal flows that the borrow checker will catch

let mut x;
// this access would be illegal, nowhere to draw the flow from:
// 这条通道将是非法的，没有地方可以引流：
// 这里是非法的，这里的x在assert_eq中用的时候x还没有初始化，所以他是不存在的。
// assert_eq!(x, 42);
1: x = 42;
// this is okay, can draw a flow from the value assigned above:
// 这是可以的，可以从上面分配的值中画出一个流程。
2: let y = &x;
// this establishes a scond, mutable flow from x:
// 这就建立了一个来自x的第二个可变的流。
3: x = 43;
// this continus the flow from y, wich in turn draws from x.
// but that flow conflicts with the assignment to x!
// 这就继续了来自y的流量，而y又从x中提取。但这一流动与分配给X的任务相冲突!
4: assert_eq!(*y,42);
```

首先，我们不能在x被初始化之前使用它，因为我们没有地方可以引出流量。只有当我们给x赋值时，我们才能从它那里提取流量。这段代码有两个流：一个从1到3的独占（&mut）流，一个从1到2到4的共享（&）流。 借阅检查器检查每个流的每个顶点，并检查是否有其他不兼容的流同时存在。在这种情况下，当借贷检查器检查3处的独占流时，它看到了终止于4处的共享流。由于你不能同时对一个值进行独占和共享使用，借贷检查器（正确地）拒绝了该代码。请注意，如果没有4，这段代码会编译得很好。共享流将在2处终止，而当排他流在3处被检查时，将不存在冲突的流。

如果一个新的变量与之前的变量同名，它们仍然被认为是不同的变量。这被称为 "阴影"--后一个变量 "阴影 "了前一个同名的变量。这两个变量共存，尽管随后的代码不再有办法命名先前的变量。这种模式与编译器，特别是借用检查器，对你的程序的推理大致吻合，而且实际上在编译器的内部使用，以产生高效的代码。



#### Low-Level Model

"变量 "命名了可能持有或不持有合法数值的内存位置。你可以把一个变量看作是一个 "值槽"。当你给它赋值时，这个槽被填满，它的旧值（如果它有的话）被丢弃并被替换。当你访问它时，编译器会检查该槽是否为空，因为这意味着该变量未被初始化或其值已被移动。一个变量的指针指的是该变量的后备内存，可以被取消引用以获得其值。例如，在语句let x: usize中，变量x是堆栈上一个内存区域的名称，该区域有空间容纳一个usize大小的值，尽管它没有一个明确的值（其槽是空的）。如果你给这个变量赋值，比如x = 6，那么这个内存区域就会容纳代表值6的比特。这个模型与C  和C++以及许多其他低级语言所使用的内存模型，在你需要明确推理内存的时候是很有用的。

> 在这个例子中，我们忽略了CPU寄存器，并将其视为一种优化。在现实中，如果一个变量不需要内存地址，编译器可能会使用一个寄存器来支持该变量，而不是一个内存区域。

你可能会发现其中一个比另一个更符合你以前的模型，但我敦促你试着把这两个模型都包在你的脑子里。它们都同样有效，而且都是简化，就像任何有用的心理模型都必须是简化的。如果你能从这两个角度来考虑一段代码，你会发现在处理复杂的代码段时要容易得多，并能理解为什么它们能或不能按照你的期望进行编译和工作。

### Memory Regions

现在你已经掌握了我们如何提及内存，我们需要谈谈内存到底是什么。内存有许多不同的区域，也许令人惊讶的是，并非所有的内存都存储在你的计算机的DRAM中。你使用哪一部分内存，对你如何编写代码有很大影响。就编写Rust代码而言，三个最重要的区域是堆栈、堆和静态内存。

#### The Stack

堆栈是一个内存段，你的程序将其作为函数调用的抓取空间。每次调用一个函数，都会在堆栈的顶部分配一个连续的内存块，称为帧。 靠近堆栈底部的是主函数的框架，当函数调用其他函数时，额外的框架被推到堆栈中。一个函数的框架包含了该函数中的所有变量，以及该函数的任何参数。当函数返回时，其堆栈框架被回收。

构成函数局部变量值的字节不会立即被抹去，但访问它们并不安全，因为它们可能已经被后续的函数调用所覆盖，其框架与回收的框架重叠了。即使它们没有被覆盖，它们也可能包含非法使用的值，例如在函数返回时被移动的值。

堆栈框架，以及至关重要的是它们最终会消失的事实，与Rust中的生命期概念密切相关。任何存储在堆栈框架中的变量在该框架消失后都不能被访问，所以对它的任何引用都必须有一个最多等同于框架寿命的寿命。

#### The Heap

堆是一个内存池，它不与程序的当前调用栈相联系。在堆内存中的值一直存在，直到它们被明确地取消分配。当你想让一个值超过当前函数框架的寿命时，这很有用。如果该值是函数的返回值，调用函数可以在其堆栈中留下一些空间，让被调用的函数在返回前将该值写入其中。但是，如果你想，比如说，把这个值发送给一个不同的线程，而当前线程可能根本就不共享堆栈框架，你可以把它存储在堆上。

"堆 "允许你明确地分配连续的内存段。当你这样做的时候，你会得到一个指向该内存段起点的指针。该内存段为你保留，直到你后来取消分配；这个过程通常被称为释放，以C标准库中相应函数的名字命名。由于从堆中分配的内存在函数返回时不会消失，你可以在一个地方为一个值分配内存，把它的指针传给另一个线程，并让这个线程安全地继续对这个值进行操作。或者，换个说法，当你用堆分配内存时，产生的指针有一个不受约束的生命期--它的生命期是你的程序让它活着的时间。

Rust中与堆交互的主要机制是Box类型。当你写Box::new(value)时，值被放在堆上，而你得到的回报（Box<T>）是一个指向堆上该值的指针。当Box最终被丢弃时，该内存就被释放了。

如果你忘记去分配堆内存，它将永远存在，你的应用程序最终会吃掉你机器上的所有内存。这被称为泄漏内存，通常是你想避免的事情。然而，在有些情况下，你会明确地想要泄漏内存。例如，假设你有一个只读的配置，整个程序都应该能够访问。你可以在堆上分配它，然后用Box::leak显式地泄露它，以获得它的 "静态引用"。

#### Static Memory

"静态内存 "实际上是位于你的程序被编译成的文件中几个密切相关的区域的总称。当程序被执行时，这些区域会自动加载到你的程序的内存中。静态存储器中的数值在程序的整个执行过程中一直存在。你的程序的静态存储器包含程序的二进制代码，通常被映射为只读。当你的程序执行时，它会逐条指令走过文本段中的二进制代码，并在调用函数时进行跳转。静态内存还保存着你用静态关键字声明的变量的内存，以及你代码中的某些常量值，如字符串。

特殊的寿命'static'，它的名字来自于静态内存区域，标志着一个引用在 "只要静态内存存在 "的情况下是有效的，也就是直到程序关闭。由于静态变量的内存是在程序开始时分配的，所以根据定义，对静态内存中的变量的引用是 "静态 "的，因为它在程序关闭前不会被删除。反之亦然--可能存在不指向静态内存的 "静态引用"--但这个名字仍然是恰当的：一旦你创建了一个具有静态寿命的引用，就程序的其余部分而言，它所指向的东西可能就在静态内存中，因为它可以被使用多长时间，你的程序就会使用多长时间。

在使用Rust时，你遇到'static lifetime'的次数要比遇到真正的静态内存（例如通过static关键字）多得多。这是因为'static'经常出现在类型参数的特质边界中。像T:'static这样的约束表明，类型参数T能够存活多久，我们就保留它多久，包括程序的剩余执行时间。从本质上讲，这种约束要求T是自有的和自足的，要么它不借用其他（非静态）的值，要么它所借用的任何东西也是 "静态的，因此将坚持到程序的结束。作为约束的 "静态 "的一个很好的例子是std::thread::spoon函数，它创建了一个新的线程，它要求你传递给它的闭包是 "静态 "的。由于新线程可能比当前线程长寿，新线程不能 "引用存储在旧线程堆栈中的任何东西"。新线程只能引用在其整个生命周期内存在的值，这可能是在程序的剩余时间内。

> 你可能想知道const与static有什么区别。const关键字将以下项目声明为常量。常量项可以在编译时被完全计算出来，任何引用它们的代码都会在编译时被替换成常量的计算值。常量没有与之相关的内存或其他存储（它不是一个地方）。你可以把常量看作是一个特定值的方便名称。



## Ownership

Rust的内存模型的中心思想是，所有的值都有一个所有者，也就是说，正好有一个位置（通常是一个作用域）负责最终取消每个值的分配。这一点是通过借贷检查器强制执行的。如果值被移动了，比如把它赋给一个新的变量，把它推给一个向量，或者把它放在堆上，值的所有权就会从旧的位置移到新的位置。在这一点上，你不能再通过来自原所有者的变量来访问该值，即使构成该值的比特在技术上仍然存在。相反，你必须通过引用其新位置的变量来访问被移动的值。

有些类型是叛徒，不遵守这个规则。如果一个值的类型实现了特殊的复制特性，那么即使该值被重新分配到一个新的内存位置，也不会被认为已经移动。相反，该值被复制，并且新旧位置都保持可访问性。从本质上讲，在移动的目的地构建了另一个相同的值的实例。Rust中的大多数原始类型，如整数和浮点类型，都是Copy。要成为Copy类型，必须能够简单地通过复制它们的位来复制该类型的值。这就排除了所有包含非Copy类型的类型，以及任何拥有资源的类型，当值被丢弃时，它必须取消分配。

要知道为什么，考虑一下如果像Box这样的类型是Copy的话会发生什么。如果我们执行box2 = box1，那么box1和box2都会认为他们拥有为box分配的堆内存，当他们超出范围时，他们都会试图释放它。释放两次内存可能会产生灾难性的后果。

当一个值的所有者不再使用它时，所有者有责任通过丢弃它对该值进行必要的清理。在Rust中，当持有该值的变量不再在范围内时，丢弃会自动发生。类型通常会递归地丢弃它们包含的值，所以丢弃一个复杂类型的变量可能会导致许多值被丢弃。由于Rust的离散所有权要求，我们不能意外地多次放弃同一个值。一个持有对另一个值的引用的变量并不拥有另一个值，所以当该变量丢弃时，该值不会被丢弃。

清单1-3中的代码对围绕所有权、移动和复制语义以及放弃的规则进行了快速总结

```rust
let x1 = 42;
let y1 = Box::new(84);
{
  // startsa new scope
  1: let z = (x1, y1);
  // z goes out of scope, and is dropes:
  // it in turn drops the values from x1 and y1
2: }
// x1's value is Copy, so it was not moved into z
3: let x2 = x1;
// y1's value is not Copy, so it was moved into z
// let y2 = y1;
```

我们一开始有两个值，数字42和一个包含数字84的Box（一个堆分配的值）。前者是Copy，而后者则不是。当我们把x1和y1放入元组z 1时，x1被复制到z中，而y1则被移到z中，此时，x1继续是可访问的，可以再次使用3。另一方面，一旦y1的值被移动4，它就变得不可访问了，任何试图访问它的行为都会引起编译器错误。当z超出范围2时，它所包含的元组值被丢弃，这反过来又丢弃了从x1复制的值和从y1移动的值。当来自y1的Box被丢弃时，它也会将用于存储y1的值的堆内存去掉。

>Drop Order
>
>当数值超出范围时，Rust会自动丢弃它们，比如清单1-3中内部范围的x1和y1。丢弃顺序的规则相当简单：变量（包括函数参数）按相反的顺序丢弃，嵌套值按源代码的顺序丢弃。
>
>这初听起来可能很奇怪--为什么会有这种差异？不过，如果我们仔细观察，它是很有意义的。假设你写了一个函数，声明了一个字符串，然后将该字符串的引用插入到一个新的哈希表中。当函数返回时，哈希表必须先被删除；如果字符串先被删除，那么哈希表就会持有一个无效的引用 一般来说，后来的变量可能包含对早期值的引用，而由于Rust的生命周期规则，反之则不能发生。出于这个原因，Rust以相反的顺序丢弃变量。
>
>现在，我们可以对嵌套的值有同样的行为，比如元组、数组或结构中的值，但这可能会让用户感到惊讶。如果你构建了一个包含两个值的数组，如果数组的最后一个元素先被丢弃，那就显得很奇怪。这同样适用于元组和结构，最直观的行为是第一个元组元素或字段先被丢弃，然后是第二个，以此类推。与变量不同的是，在这种情况下没有必要颠倒丢弃顺序，因为Rust（目前）不允许在单个值中进行自我引用。所以，Rust采用的是直观的选项。

## Borrowing and Lifetimes

Rust允许一个价值的所有者通过引用将该价值出借给其他人，而不放弃所有权。引用是一个指针，它带有一个关于如何使用它的附加契约，比如引用是否提供对被引用值的独占访问，或者被引用值是否也可以有其他引用指向它。

### Shared References

共享引用，&T，顾名思义，是一个可以共享的指针。任何数量的其他引用都可能存在于相同的值上，每个共享引用都是复制的，所以你可以轻而易举地制造更多的引用。共享引用后面的值是不可变的；你不能修改或重新分配一个共享引用所指向的值，也不能把一个共享引用投给一个可变的值。

Rust编译器被允许假设共享引用所指向的值在该引用存在期间不会改变。例如，如果Rust编译器看到一个共享引用背后的值在一个函数中被多次读取，那么它就有权只读取一次并重用该值。更具体地说，清单1-4中的断言不应该失败。

```rust
// Listing 1-4: Rust assumes that shared references are immmutable

fn cache(input: &i32, sum: &mut i32) {
  *sum = *input + *input;
  assert_eq!(*sum, 2* *input);
}
```

编译器是否选择应用一个给定的优化或多或少是不相关的。编译器的启发式方法会随着时间的推移而改变，所以你通常希望针对编译器允许做的事情进行编码，而不是针对它在某一特定时刻的实际做法。

### Mutable References

共享引用的替代方案是变异引用：&mut T。有了变异引用，Rust编译器又被允许充分利用引用自带的契约：编译器假设没有其他线程访问目标值，无论是通过共享引用还是变异引用。换句话说，它假定易变引用是独占的。这使得一些有趣的优化成为可能，这些优化在其他语言中是不容易实现的。以清单1-5中的代码为例。

```rust
// listing 1-5: Rust assumes that mutable references are exclusive.
fn nolias(input: &i32, output: &mut i32) {
  if *input == 1{
    1: *output = 2;
  }
  2: if *input != 1 {
    *output = 3;
  }
}
```

在Rust中，编译器可以假设输入和输出不指向同一内存。因此，1处输出的重新分配不能影响2处的检查，整个函数可以被编译为一个单一的if-else块。如果编译器不能依赖排他性可变性契约，那么这种优化就会失效，因为在noalias(&x, &mut x)这样的情况下，1的输入可能导致3的输出。

一个可改变的引用只允许你改变该引用所指向的内存位置。你是否可以改变直接引用之外的值，取决于位于两者之间的类型所提供的方法。用一个例子可能更容易理解，所以考虑清单1-6。

```rust
// listing 1-6: Mutability applies only to the immediately referenced memory.

let x = 42;
let mut y = &x; // y is of type &i32
let z = &mut y; // z is of type &mut &i32
```

在这个例子中，你能够通过让指针y引用一个不同的变量来改变它的值（也就是一个不同的指针），但你不能改变被指向的值（也就是x的值）。同样地，你可以通过z来改变y的指针值，但你不能改变z本身来持有不同的引用。

拥有一个值和拥有一个可变的引用之间的主要区别是，所有者负责在不再需要的时候丢弃这个值。除此之外，你可以通过一个可改变的引用做任何事情，如果你拥有这个值的话，有一个注意事项：如果你把这个值移到可改变的引用后面，那么你必须在它的位置上留下另一个值。如果你不这样做，所有者仍然会认为它需要放弃这个值，但是它将没有值可以放弃！

```rust
// listing 1-7 gives an example of the ways in which you can move the value behind a mutable reference.
// listing 1-7: Access through a mutable reference must leave a value behind.
fn replace_with_84(s: &mut Box<i32>) {
  // this is no okay, as *s would be empty:
  1: // let was = *s;
  // but this is:
  2: let was = std::mem::take(s);
  // so is this:
  3: *s = was;
  // we can exchange values behind &mut:
  let mut r = Box::new(84);
  4: std::mem::swap(s, &mut r);
  assert_ne!(*r, 84);
}
let mut s = Box::new(42);
replace_with_84(&mut s);
5: 
```

我已经添加了代表非法操作的注释行。你不能简单地将值移出1，因为调用者仍会认为他们拥有该值，并会在5处再次释放它，导致双重释放。如果你只是想留下一些有效的值，std::mem::take 2是一个不错的选择。它相当于std::mem::replace(&mut value, Default::default())；它将值从可变引用后面移出，但为该类型留下一个新的、默认的值。默认值是一个单独的、自有的值，所以当作用域在5处结束时，调用者可以安全地放弃它。

另外，如果你不需要引用后面的旧值，你可以用一个你已经拥有的值来覆盖它3，让调用者以后再丢弃这个值。当你这样做的时候，原来在可变引用后面的值会被立即丢弃。

最后，如果你有两个易变的引用，你可以在不拥有其中任何一个的情况下交换它们的值4，因为两个引用最后都会有一个合法拥有的值供它们的所有者最终释放。

### Interior Mutability

有些类型提供内部可变性，这意味着它们允许你通过共享引用来变异一个值。这些类型通常依靠额外的机制（如原子CPU指令）或不变性来提供安全的可变性，而不依赖排他性引用的语义。这些通常分为两类：一类是让你通过共享引用获得一个可变的引用，另一类是让你替换一个只给定共享引用的值。

第一类由Mutex和RefCell等类型组成，它们包含安全机制，以确保对于它们给出的任何值的可变参考，一次只能存在一个可变参考（而没有共享参考）。在引擎盖下，这些类型（和那些类似的类型）都依赖于一个叫做UnsafeCell的类型，它的名字应该立刻让你对使用它感到犹豫。我们将在第9章详细介绍UnsafeCell，但现在你应该知道它是通过共享引用进行变异的唯一正确方法。

提供内部可变性的其他类别的类型是那些不给出内部值的可变性引用，而只是给你在原地操作该值的方法。std::sync::atomic中的原子整数类型和std::cell::Cell类型就属于这个类别。你不能直接获得对这种类型背后的usize或i32的引用，但你可以在一个给定的时间点上读取和替换它的值。

> 标准库中的Cell类型是一个有趣的例子，它通过不变量实现了安全的内部可变性。它不能跨线程共享，也不会给出对单元格中所包含的值的引用。相反，所有的方法要么完全替换该值，要么返回所含值的一个副本。因为没有对内部值的引用存在，所以移动它总是可以的。而且，由于Cell不能跨线程共享，即使变异是通过共享引用发生的，内部值也不会被并发变异。

### Lifetimes

如果你正在读这本书，你可能已经熟悉了生命期的概念，可能是通过编译器对生命期规则违反的反复通知。这种程度的理解对于你将要写的大多数Rust代码来说是很好的，但是当我们深入到Rust的更复杂的部分时，你将需要一个更严格的心理模型来工作。


新的Rust开发者经常被教导要把生命期看作是与作用域相对应的：当你获取某个变量的引用时，生命期就开始了，当该变量被移动或超出作用域时就结束了。这通常是正确的，而且通常很有用，但实际情况要复杂一些。生命期实际上是一个代码区域的名称，一些引用必须在该区域内有效。虽然生命期经常与作用域重合，但它并不是必须的，我们将在本节的后面看到。

#### Lifetimes and the Borrow Checker

Rust lifetimes的核心是借用检查器。每当一个具有某种寿命的引用'a'被使用时，借用检查器就会检查'a'是否仍然活着。它通过追踪路径回到'a'开始的地方--引用被取走的地方--从使用点开始，并检查该路径上是否有冲突的使用。这确保了引用仍然指向一个可以安全访问的值。这类似于我们在本章前面讨论的高级 "数据流 "心理模型；编译器检查我们正在访问的引用的流不会与任何其他并行流相冲突。

清单1-8显示了一个简单的代码例子，其中有对x的引用的寿命注释。

```rust
// 1-8 shows a simple code example with lifetime annotations for the reference to x.
// listing 1-8: lifetimes dot not need to be contiguous.
let mut x = Box::new(42);
1: let r = &x; // 'a
if rand() > 0.5 {
  2: *x = 84;
}else{
  3: println!("{}", r); //'a
}
4:
```

当我们获取对x的引用时，生命期从1开始。在第一个分支2中，我们立即尝试修改x，将其值改为84，这需要一个&mut x。它发现在获取引用和使用引用之间没有冲突，所以它接受了这段代码。如果你习惯于将生命周期视为作用域的话，这可能会让你感到惊讶，因为r在2的时候仍然在作用域中（在4的时候出了作用域）。但是借贷检查器足够聪明，它意识到如果这个分支被选中，以后就不会再使用r，因此x在这里被可变访问是没有问题的。或者，换句话说，在1处创建的生命期并没有延伸到这个分支：在2处之后没有来自r的流，因此没有冲突的流。然后，借贷检查器在3处的打印语句中发现了r的使用。它沿着路径回到1处，发现没有冲突的使用（2不在该路径上），所以它也接受这个使用。

如果我们在清单1-8中的4处增加了对r的使用，代码就不能再编译了。a的生命周期将从1一直持续到4（r的最后一次使用），当借贷检查器检查我们对r的新使用时，它将发现2处有一个冲突的使用。

寿命可以变得相当复杂。在清单1-9中，你可以看到一个有漏洞的生命周期的例子，它在开始和最终结束的地方间歇性地无效。

```rust
// listing 1-9: lifetimes can have holes.
let mut x = Box::new(42);
1: let mut z = &x; // 'a
for i in 0..100 {
  2: println!("{}",z); //'a
  3: x = Box::new(i);
  4: z = &x; //'a
}
println!("{}",z); // 'a
```

当我们获取对x的引用时，生命期从1开始。然后我们在3处移出x，这结束了'a'的生命期，因为它不再有效。借贷检查器认为'a'在2处结束，这使得3处的x没有冲突的流量，从而接受了这一举动。 然后，我们通过更新z 4中的引用来重新启动生命周期。 无论代码现在是循环回到2处还是继续到最后的打印语句，这两个用途现在都有一个有效的值可以流出来，而且没有冲突的流量，所以借贷检查器接受了代码！

同样，这与我们之前讨论的内存的数据流模型完全吻合。当x被移动时，z停止存在。当我们稍后重新分配z时，我们创建了一个全新的变量，这个变量只从这一点开始存在。碰巧的是，这个新变量也被命名为z。考虑到这个模型，这个例子并不奇怪。

> 同样，这与我们之前讨论的内存的数据流模型完全吻合。当x被移动时，z停止存在。当我们稍后重新分配z时，我们创建了一个全新的变量，这个变量只从这一点开始存在。碰巧的是，这个新变量也被命名为z。考虑到这个模型，这个例子并不奇怪。



#### Gereric Lifetimes

偶尔你需要在你自己的类型中存储引用。这些引用需要有一个生命周期，这样当它们被用于该类型的各种方法时，借贷检查器可以检查它们的有效性。如果你想让你的类型上的一个方法返回一个比对自己的引用更久远的引用，这一点尤其正确。

Rust允许你让一个类型定义在一个或多个生命期上通用，就像它允许你让它在类型上通用一样。Steve Klabnik和Carol Nichols的《Rust编程语言》（No Starch Press，2018）对这一主题做了一些详细介绍，所以我不会在这里重申基础知识。但是，当你编写这种性质的更复杂的类型时，围绕这种类型和生命期之间的互动，有两个微妙的问题，你应该注意。

首先，如果你的类型也实现了Drop，那么丢弃你的类型也算作是对你的类型的泛型寿命或类型的使用。基本上，当你的类型的一个实例被丢弃时，借贷检查器将检查在丢弃它之前使用你的类型的任何泛型寿命是否仍然合法。这是必要的，以防你的丢弃代码确实使用了任何这些引用。如果你的类型没有实现 Drop，丢弃这个类型就不算是使用，用户只要不再使用你的类型，就可以自由地忽略存储在你的类型中的任何引用，就像我们在清单 1-7 中看到的那样。我们将在第9章中更多地讨论这些关于放弃的规则。

第二，虽然一个类型可以在多个生命周期内通用，但经常这样做只会让你的类型签名变得不必要的复杂。通常情况下，一个类型在一个生命周期内是通用的就可以了，编译器会将插入到你的类型中的任何引用的生命周期中较短的一个作为这个生命周期。只有当你有一个包含多个引用的类型，而它的方法返回的引用应该只与其中一个引用的寿命挂钩时，你才应该真正使用多个泛型寿命参数。

考虑一下清单1-10中的类型，它为你提供了一个由特定的其他字符串分隔的字符串部分的迭代器。

```rust
// Listing 1-10: A type that needs to be generic over multiple lifetimes
struct StrSplit<'s, 'p> {
  delimiter: &'p str,
  document: &'s str,
}
impl<'s, 'p> Iterator for StrSplit<'s, 'p> {
  type Item = &'s str;
  fn next(&self) -> Option<Self::Item> {
    todo!()
  }
}

fn str_before(s: &str,c: char) -> Option<&str> {
  StrSplit{ document: s, delimiter: &c.to_string()}.next()
}
```

当你构建这个类型时，你必须给出分隔符和要搜索的文档，这两个都是对字符串值的引用。当你要求下一个字符串时，你会得到一个对文档的引用。考虑一下如果你在这个类型中使用一个单一的生命周期会发生什么。迭代器产生的值将与文档的生命周期和分隔符相联系。这将使str_before无法编写：返回类型将有一个与函数本地变量相关的生命周期--to_string产生的String--借贷检查器将拒绝该代码。

#### Lifetime Variance

"差异 "是程序员经常接触到的一个概念，但很少知道它的名字，因为它大多是看不见的。简而言之，差异性描述了哪些类型是其他类型的子类型，以及何时可以用子类型来代替超类型（反之亦然）。广义上讲，如果一个类型A至少和B一样有用，那么它就是另一个类型B的子类型。 Variance就是为什么在Java中，如果Turtle是Animal的子类型，你可以把Turtle传给接受Animal的函数，或者在Rust中，你可以把&'static str传给接受&'a str的函数。

虽然变异通常隐藏在视线之外，但它经常出现，我们需要对它有一个工作上的了解。乌龟是动物的一个亚类型，因为乌龟比某些未指定的动物更 "有用"--乌龟可以做任何动物能做的事情，而且可能更多。同样，"静态 "是 "a "的一个子类型，因为 "静态 "的寿命至少与任何 "a "一样长，所以更有用。或者，更一般地说，如果'b：'a（'b比'a长寿），那么'b就是'a的一个子类型。这显然不是正式的定义，但它已经足够接近实际用途了。

所有类型都有一个方差，它定义了哪些其他类似的类型可以用于该类型的位置。有三种方差：共变、不变、和不变型。如果你可以只使用一个子类型来代替该类型，那么该类型就是协变的。例如，如果一个变量是&'a T类型的，你可以给它提供一个&'static T类型的值，因为&'a T在'a中是协变的。&'a T在T中也是协变的，所以你可以把一个&Vec<&'static str>传递给一个接受&Vec<&'a str>的函数。

有些类型是不变的，这意味着你必须准确地提供给定的类型。&mut T就是这样一个例子--如果一个函数接受一个&mut Vec<&'a str>，你不能把一个&mut Vec<&'static str>传递给它。也就是说，&mut T在T中是不变的。如果你可以，函数可以在Vec中放入一个短暂的字符串，然后调用者会继续使用它，认为它是一个Vec<&'static str>，从而认为包含的字符串是 "静态的！"。任何提供可变性的类型一般都是不变的，原因也是如此--例如，Cell<T>在T中是不变的。

最后一类，即禁忌，出现在函数参数上。如果函数类型可以接受其参数不那么有用，那么它们就会更有用。如果你将参数类型本身的方差与它们作为函数参数时的方差进行对比，这一点就更清楚了：

```rust
let x: &'static str; // mote useful, live longer
let x: &'a str; // less useful, lives shorter

fn take_func1(&'static str) // stricter, so less useful
fn take_func2(&'a str) // less strict, more useful
```

这种翻转的关系表明，Fn(T)在T中是禁变量。

那么，当涉及到寿命时，你为什么需要学习方差呢？当你考虑通用寿命参数如何与借贷检查器交互时，方差就变得相关了。考虑像清单1-11中所示的类型，它在一个字段中使用了多个寿命。

```rust
// listing1-11: A type that needs to be generic over multiple lifetimes
struct MutStr<'a, 'b> {
  s: &'a mut &'b str
}
let mut s = "Hello";
1: &MutStr {s: &mut s}.s = "world";
println!("{}", s);
```

乍一看，在这里使用两个生命期似乎没有必要--我们没有需要区分结构中不同部分的借贷的方法，就像我们在清单1-10中的StrSplit那样。但是如果你用一个'a'来代替这里的两个生命期，代码就不再能编译了！这都是因为变异。而这一切都是因为变异。

> 1处的语法可能看起来很陌生。它相当于定义了一个持有MutStr的变量x，然后写*x.s = "world"，只是没有变量，所以MutStr被立即删除。

在1处，编译器必须确定寿命参数应该被设置为什么寿命。如果有两个寿命，'a'被设置为有待确定的s的借贷寿命，'b'被设置为'静态'，因为那是提供的字符串 "hello "的寿命。如果只有一个生命期'a'，编译器会推断该生命期必须是'静态'。

当我们以后试图通过共享引用访问字符串引用s来打印它时，编译器会尝试缩短MutStr使用的s的可变借用，以允许s的共享借用。

在双生命周期的情况下，'a'只是在println之前结束，'b'保持不变。另一方面，在单时限的情况下，我们遇到了问题。编译器想缩短s的借用，但要做到这一点，它也必须缩短str的借用。虽然&'static str一般来说可以缩短为任何&'a str（&'a T在'a中是共变的），但这里它在&mut T后面，而&mut T在T中是不变量的。不变量要求相关类型永远不会被子类型或超类型取代，所以编译器缩短借用的尝试失败了，它报告说列表仍然是可变的借用。哎哟！

由于不变性带来的灵活性的降低，你想确保你的类型在尽可能多的通用参数上保持协变性（或在适当的情况下保持协变性）。如果这需要引入额外的寿命参数，你需要仔细权衡增加另一个参数的认知成本和不变性的人机工程成本。

## Summary

本章的目的是建立一个坚实的、共享的基础，我们可以在接下来的章节中建立这个基础。到现在，我希望你觉得你已经牢牢掌握了Rust的内存和所有权模型，那些你可能从借用检查器中得到的错误似乎不那么神秘了。你可能已经知道了我们在这里所涉及的零星内容，但希望这一章能给你一个更全面的印象，让你知道这一切是如何结合起来的。在下一章中，我们将为类型做一些类似的事情。我们将讨论类型是如何在内存中表示的，看看泛型和特质是如何产生运行代码的，并看看Rust为更高级的用例提供的一些特殊类型和特质结构。